# Engineer Work

Este √© o comando para executar o desenvolvimento de uma funcionalidade seguindo o planejamento estabelecido.

## Configura√ß√£o de IA

Antes de executar este comando, leia o arquivo `ai.properties.md` na raiz do projeto para obter configura√ß√µes locais.

Se o arquivo n√£o existir ou n√£o estiver configurado, use a URL padr√£o do GitHub.

## Argumentos da Sess√£o

<folder>
#$ARGUMENTS
</folder>

## Modos de Execu√ß√£o (Otimizador de Contexto)

### Modos Pr√©-definidos (Sem Par√¢metros)

**Modo Lite (‚â§25k tokens)**:

- `plan.md`: somente fase atual (bloco), n√∫mero/status + 3 pr√≥ximos passos
- TL;DR: Angular Best Practices, Code Standards (index), Frontend Architecture (index)
- Sem docs longos, sem Top-3 trechos, sem Jira
- Respeita Ignore List

**Modo Standard (‚â§60k tokens)**:

- TL;DR adicionais: `angular-modern-patterns`, `design-system-patterns`, `ui-system`, `testing-strategy`
- Para a fase atual, carregar apenas se√ß√µes relevantes via √¢ncoras (Top-3 trechos curtos por doc)
- Resumo enxuto (‚â§10 bullets) com links/√¢ncoras; sem colar trechos longos

**Modo Full (‚â§100k tokens)**:

- Apenas por configura√ß√£o expl√≠cita do sistema
- Igual ao Standard, podendo incluir +1‚Äì2 se√ß√µes ancoradas por doc cr√≠tico
- Nunca imprimir documentos inteiros

### Sele√ß√£o Autom√°tica de Modo

- **Fases iniciais** (1-2): Lite (elevar p/ Standard se complexidade ‚â• m√©dia)
- **Fases de desenvolvimento** (3 at√© pen√∫ltima): Standard
- **Fase final** (testes/valida√ß√£o): Standard; elevar p/ Full somente se reescrever estrat√©gia de testes
- **Fase p√≥s-entrega**: Lite
- Se a proje√ß√£o exceder o teto do modo: degradar automaticamente p/ modo inferior

### Hard Cap e Contabiliza√ß√£o

- Estimar custo antes de ler: TL;DR (baixo), Top-3 (m√©dio), bloco da fase (baixo)
- Interromper carregamentos ao atingir 95% do teto; registrar itens diferidos
- **TETO ABSOLUTO**: 100.000 tokens (nunca exceder)

### Ignore List (n√£o ler/imprimir)

- `documentation.json`, `storybook-static/**`, `.storybook/**`, `coverage/**`, `dist/**`, `sessions/*/work-log.md`, `public/mockServiceWorker.js`, `temp/*-context-inventory.md`

## Objetivo

Implementar a funcionalidade seguindo o plano faseado, com foco na qualidade, padr√µes do projeto e aprova√ß√£o entre etapas.
Voc√™ possui o MCP angular-cli do Angular que te fornece boas pr√°ticas, use ele sempre que for trabalhar.

## Processo de Desenvolvimento

### 0. Execu√ß√£o Autom√°tica Inicial

**OBRIGAT√ìRIO**: Execute estas a√ß√µes automaticamente no in√≠cio:

#### Passo 1: Verifica√ß√£o e Cria√ß√£o de Branch

```bash
# Verificar branch atual
git branch --show-current

# Se n√£o estiver em feature branch, criar uma
# Formato: feature-{nome-da-pasta-da-sessao}
```

Se n√£o estiver em uma feature branch:

1. Pergunte ao usu√°rio: "Posso criar a feature branch `feature-{folder-name}`?"
2. Ap√≥s confirma√ß√£o, execute: `git checkout -b feature-{folder-name}`

#### Passo 2: Prepara√ß√£o da Sess√£o (OBRIGAT√ìRIO)

**SEMPRE execute este passo ANTES do Context Loading**:

‚Äì Leia os documentos da sess√£o para entender a demanda espec√≠fica.
‚Äì Identifique a fase atual e necessidades espec√≠ficas.
‚Äì Com base na demanda, direcione o Context Loading para documentos relevantes.

##### 2.1: An√°lise dos Documentos da Sess√£o

**Leia automaticamente se existirem**:

1. **context.md**: Requisitos e contexto da funcionalidade
2. **architecture.md**: Design t√©cnico detalhado
3. **layout-specification.md**: Especifica√ß√µes de UI/UX e layout ‚≠ê NOVO
4. **plan.md**: Plano faseado de implementa√ß√£o (se j√° existir)

‚Äì Extraia apenas a se√ß√£o marcada como "Em Progresso ‚è∞" ou a pr√≥xima pendente do `plan.md`.

##### 2.2: Identifica√ß√£o da Fase Atual

Algoritmo de detec√ß√£o robusto (regex + normaliza√ß√£o):

```typescript
// 1) Ler apenas o arquivo do plano da sess√£o atual
const planPath = `sessions/${folder}/plan.md`;
const planContent = await read_file({ target_file: planPath });

// 2) Extrair fases pelos headings formais
// Formato esperado: "## üìÖ FASE X: T√≠tulo [Status: ...]"
const phaseRegex = /^##\s*üìÖ\s*FASE\s*(\d+)\s*:.*?\[\s*Status\s*:\s*([^\]]+)\]/gim;
type PhaseStatus = 'completed' | 'in_progress' | 'pending' | 'unknown';

function normalizeStatus(raw: string): PhaseStatus {
  const s = raw.toLowerCase();
  if (s.includes('‚è∞') || s.includes('em progresso') || s.includes('in progress'))
    return 'in_progress';
  if (s.includes('‚úÖ') || s.includes('conclu') || s.includes('completed') || s.includes('100%'))
    return 'completed';
  if (s.includes('‚è≥') || s.includes('pendente') || s.includes('pending')) return 'pending';
  return 'unknown';
}

interface PhaseInfo {
  num: number;
  status: PhaseStatus;
  headingIndex: number;
}
const phases: PhaseInfo[] = [];
let match: RegExpExecArray | null;
while ((match = phaseRegex.exec(planContent)) !== null) {
  const num = Number(match[1]);
  const status = normalizeStatus(match[2] ?? '');
  phases.push({ num, status, headingIndex: match.index });
}

// 3) Sele√ß√£o da fase atual
// Regra:
// - Se existir alguma com status in_progress ‚Üí escolha a de menor n√∫mero (ou √∫nica)
// - Sen√£o, escolha a primeira fase "pendente" imediatamente ap√≥s a √∫ltima "conclu√≠da"
// - Se todas conclu√≠das, considere a √∫ltima como finalizado
phases.sort((a, b) => a.num - b.num);
let current: PhaseInfo | undefined = phases.find((p) => p.status === 'in_progress');
if (!current) {
  const lastCompleted = [...phases].reverse().find((p) => p.status === 'completed');
  if (lastCompleted) {
    current = phases.find((p) => p.num > lastCompleted.num && p.status !== 'completed');
  }
  if (!current) {
    current = phases.find((p) => p.status === 'pending' || p.status === 'unknown') ?? phases.at(-1);
  }
}

// 4) Extra√ß√£o parcial do conte√∫do da fase atual (quando enabled)
let currentPhaseMarkdown = '';
if (current) {
  if (work.partialReads?.planCurrentPhaseOnly) {
    const nextHeading = phases.find((p) => p.num > current!.num);
    const start = current.headingIndex;
    const end = nextHeading ? nextHeading.headingIndex : planContent.length;
    currentPhaseMarkdown = planContent.slice(start, end);
  } else {
    currentPhaseMarkdown = planContent;
  }
}

// 5) Fallback opcional: ignorar se√ß√µes como "Atualiza√ß√µes Recentes" para n√£o confundir status
// O algoritmo acima considera apenas headings formais de fase.

return {
  currentPhaseNumber: current?.num,
  currentPhaseStatus: current?.status,
  currentPhaseMarkdown,
};
```

##### 2.3: Sele√ß√£o de Modo Baseada na Fase

**Sele√ß√£o Autom√°tica de Modo**:

- Fases 1‚Äì2: Lite (elevar p/ Standard se complexidade ‚â• m√©dia)
- Fases 3‚Äì7: Standard
- Fase 8 (testes/valida√ß√£o): Standard; elevar p/ Full somente se reescrever estrat√©gia de testes
- Fase 9: Lite
- Se a proje√ß√£o exceder o teto do modo: degradar automaticamente p/ modo inferior

#### Passo 3: Context Loading Inteligente (OBRIGAT√ìRIO)

**SEMPRE execute este passo AP√ìS entender a demanda**:

‚Äì Metaspecs e Angular Best Practices s√£o lidos via cache por hash/TTL; se inalterados, reutilize TL;DR em `temp/context-cache/`.
‚Äì **NOVO**: Com base na fase identificada, carregar apenas documentos/se√ß√µes relevantes.

##### 3.1: An√°lise de Contexto Autom√°tica

**Execute automaticamente com CONTABILIZA√á√ÉO DE TOKENS**:

```typescript
// CONTABILIZA√á√ÉO DE TOKENS - Hard Cap 100k
let tokenCount = 0;
const HARD_CAP = 100000;
const INTERRUPT_THRESHOLD = 95000; // 95% do teto

function estimateTokens(content: string): number {
  // Estimativa: ~4 chars por token
  return Math.ceil(content.length / 4);
}

function checkTokenLimit(): boolean {
  if (tokenCount >= INTERRUPT_THRESHOLD) {
    console.log(`‚ö†Ô∏è Token limit atingido: ${tokenCount}/${HARD_CAP}. Interrompendo carregamentos.`);
    return false;
  }
  return true;
}
```

1. **Busca Contextual Inteligente Guiada por Demanda**:

   ```typescript
   // Use codebase_search para encontrar documentos relevantes baseado na fase atual
   const contextQuery = `funcionalidade ${folder - name} arquitetura padr√µes frontend`;
   const contextResults = await codebase_search({
     query: contextQuery,
     target_directories: [leia meta_specs_path do arquivo ai.properties.md na raiz do projeto],
   });

   // Contabilizar tokens
   tokenCount += estimateTokens(contextResults.content);
   if (!checkTokenLimit()) return;
   ```

- Limite buscas a Top 5 resultados e gere apenas resumo curto.
- **NOVO**: Com base na fase identificada, direcione a busca para se√ß√µes espec√≠ficas (ex: fase de testes ‚Üí testes, acessibilidade, performance).
- **HARD CAP**: Interromper carregamentos ao atingir 95% do teto (95k tokens).

2. **Gera√ß√£o de Context Summary**:

   ```typescript
   // Analise os resultados da busca
   const summary = generateContextSummary(contextResults);
   tokenCount += estimateTokens(summary);
   if (!checkTokenLimit()) return;
   ```

   - Analise os resultados da busca
   - Identifique documentos mais relevantes
   - Gere summary autom√°tico dos padr√µes encontrados
   - Identifique gaps de conhecimento

3. **Cache de Contexto**:
   ```typescript
   // Verifique se contexto similar j√° foi carregado
   const cachedContext = await checkCache();
   if (cachedContext) {
     tokenCount += estimateTokens(cachedContext);
     if (!checkTokenLimit()) return;
   }
   ```
   - Verifique se contexto similar j√° foi carregado
   - Reutilize informa√ß√µes de sess√µes anteriores quando aplic√°vel
   - Atualize cache com novas descobertas

##### 3.2: Navega√ß√£o Inteligente das Meta Specs

**üß† SISTEMA DE NAVEGA√á√ÉO AUTOM√ÅTICA GUIADA POR DEMANDA**:

Use os pr√≥prios √≠ndices das Meta Specs para navega√ß√£o inteligente, direcionada pela fase atual:

```typescript
// 1. Ler ai.properties.md para obter meta_specs_path
const aiProperties = await read_file({ target_file: 'ai.properties.md' });
tokenCount += estimateTokens(aiProperties);
if (!checkTokenLimit()) return;

const metaSpecsPath = extractMetaSpecsPath(aiProperties);

// 2. Ler √≠ndice principal das Meta Specs
const metaSpecsIndex = await read_file({
  target_file: `${metaSpecsPath}/index.md`,
});
tokenCount += estimateTokens(metaSpecsIndex);
if (!checkTokenLimit()) return;

// 3. NAVEGA√á√ÉO INTELIGENTE - Use os √≠ndices para descobrir estrutura
const codeStandardsIndex = await read_file({
  target_file: `${metaSpecsPath}/technical/code-standards/index.md`,
});
tokenCount += estimateTokens(codeStandardsIndex);
if (!checkTokenLimit()) return;

const frontendArchIndex = await read_file({
  target_file: `${metaSpecsPath}/technical/frontend-architecture/index.md`,
});
tokenCount += estimateTokens(frontendArchIndex);
if (!checkTokenLimit()) return;

// 4. NOVO: Sele√ß√£o Guiada por Fase
// Com base na fase atual identificada, carregar apenas se√ß√µes relevantes:

function getRelevantSectionsForPhase(
  phaseNumber: number,
  phaseStatus: string,
  totalPhases: number
): string[] {
  const sections: string[] = [];

  // Sempre incluir bases
  sections.push('index.md', 'code-standards/index.md', 'frontend-architecture/index.md');

  // Fases espec√≠ficas baseadas no status e posi√ß√£o
  if (phaseStatus === 'testes' || phaseStatus === 'valida√ß√£o' || phaseNumber === totalPhases) {
    sections.push('technical/04_estrategia_testes.md');
    sections.push('technical/code-standards/design-system-patterns.md'); // Acessibilidade
    sections.push('technical/frontend-architecture/ui-system.md'); // Performance
  }

  // Fases de desenvolvimento (meio do plano)
  if (phaseNumber >= 3 && phaseNumber < totalPhases) {
    sections.push('technical/code-standards/angular-modern-patterns.md');
    sections.push('technical/code-standards/design-system-patterns.md');
    sections.push('technical/frontend-architecture/ui-system.md');
  }

  // Fases iniciais
  if (phaseNumber <= 2) {
    sections.push('technical/code-standards/angular-modern-patterns.md');
  }

  return sections;
}

const relevantSections = getRelevantSectionsForPhase(
  currentPhaseNumber,
  currentPhaseStatus,
  phases.length
);

// 5. OBRIGAT√ìRIO: Obter melhores pr√°ticas Angular via MCP
const angularBestPractices = await mcp_angular_cli_get_best_practices();
tokenCount += estimateTokens(angularBestPractices);
if (!checkTokenLimit()) return;

// 6. Carregar apenas se√ß√µes relevantes com contabiliza√ß√£o
for (const section of relevantSections) {
  const content = await read_file({ target_file: `${metaSpecsPath}/${section}` });
  tokenCount += estimateTokens(content);
  if (!checkTokenLimit()) {
    console.log(
      `‚ö†Ô∏è Limite de tokens atingido. Se√ß√µes restantes: ${relevantSections.slice(
        relevantSections.indexOf(section)
      )}`
    );
    break;
  }
}

// 5. AN√ÅLISE CONTEXTUAL INTELIGENTE
await performIntelligentAnalysis({
  metaSpecsIndex: metaSpecsIndex,
  codeStandardsIndex: codeStandardsIndex,
  frontendArchIndex: frontendArchIndex,
  featureContext: featureAnalysis,
  angularBestPractices: angularBestPractices,
});
```

- Cacheie o TL;DR das Best Practices em `temp/context-cache/angular-best-practices.tldr.md` (TTL configur√°vel) e referencie-o sem imprimir conte√∫do completo.

**üéØ PRINC√çPIOS DA NAVEGA√á√ÉO INTELIGENTE**:

1. **Use os √≠ndices como mapa**: Cada `index.md` cont√©m a estrutura e navega√ß√£o
2. **An√°lise contextual autom√°tica**: Baseada no tipo de funcionalidade
3. **Descoberta din√¢mica**: A IA descobre quais documentos s√£o relevantes
4. **Manuten√ß√£o zero**: Mudan√ßas nas Meta Specs n√£o afetam o work.md

**üîß INTEGRA√á√ÉO COM MCP ANGULAR-CLI**:

**SEMPRE execute antes de qualquer implementa√ß√£o Angular**:

```typescript
// 1. Obter melhores pr√°ticas Angular
const bestPractices = (await mcp_angular) - cli_get_best_practices();

// 2. Buscar documenta√ß√£o espec√≠fica se necess√°rio
const angularDocs =
  (await mcp_angular) -
  cli_search_documentation({
    query: 'standalone components signals inject',
  });

// 3. Aplicar pr√°ticas no contexto da funcionalidade
const contextualPractices = await applyAngularPractices({
  bestPractices: bestPractices,
  featureContext: featureAnalysis,
  existingPatterns: similarFeatures,
});
```

**üìã AN√ÅLISE INTELIGENTE BASEADA EM √çNDICES**:

A IA deve:

- [ ] **Analisar o √≠ndice principal** para entender a estrutura geral
- [ ] **Navegar pelos √≠ndices** de code-standards e frontend-architecture
- [ ] **Identificar se√ß√µes relevantes** baseado no tipo de funcionalidade
- [ ] **Ler documentos espec√≠ficos** conforme identificado pelos √≠ndices
- [ ] **Aplicar padr√µes identificados** no contexto da funcionalidade
- [ ] **Validar consist√™ncia** com padr√µes existentes no codebase

##### 2.2.1: Navega√ß√£o Expl√≠cita em Code Standards

**üéØ NAVEGA√á√ÉO OBRIGAT√ìRIA EM CODE-STANDARDS**:

A IA deve navegar explicitamente pelo √≠ndice de code-standards e ler documentos relevantes

```typescript
// 1. Ler √≠ndice de code-standards
const codeStandardsIndex = await read_file({
  target_file: `${metaSpecsPath}/technical/code-standards/index.md`,
});

// 2. NAVEGA√á√ÉO EXPL√çCITA - Identificar se√ß√µes relevantes
const codeStandardsSections = await identifyRelevantSections({
  index: codeStandardsIndex,
  featureContext: featureAnalysis,
});

// 3. LEITURA CONTEXTUAL - Ler documentos identificados
for (const section of codeStandardsSections) {
  const content = await read_file({ target_file: section.path });
  await analyzeCodeStandards({
    document: content,
    section: section.name,
    context: featureAnalysis,
    angularBestPractices: angularBestPractices,
  });
}
```

**üìã CHECKLIST DE NAVEGA√á√ÉO EM CODE-STANDARDS**:

- [ ] **Ler √≠ndice completo** de code-standards
- [ ] **Identificar se√ß√µes relevantes** baseado no contexto da funcionalidade
- [ ] **Ler documentos espec√≠ficos** conforme identificado
- [ ] **Mapear conven√ß√µes de nomenclatura** espec√≠ficas
- [ ] **Identificar padr√µes do Design System** (os-\*)
- [ ] **Extrair guidelines de performance** e otimiza√ß√£o
- [ ] **Mapear padr√µes de error handling** (Either pattern)

##### 2.5: Documentos Contextuais Adicionais

**Baseado na an√°lise autom√°tica, leia adicionalmente**:

- Documentos identificados pela busca contextual
- ADRs relevantes para a funcionalidade espec√≠fica
- Especifica√ß√µes de dom√≠nio relacionadas
- Documenta√ß√£o t√©cnica espec√≠fica do contexto

**Localiza√ß√£o**: [leia meta_specs_path do arquivo ai.properties.md na raiz do projeto, ou use 'https://github.com/danilotandrade1518/orca-sonhos-meta-specs' se n√£o configurado]

##### 2.6: Descoberta Inteligente de Padr√µes Existentes

**üîç BUSCA CONTEXTUAL INTELIGENTE**:

Use busca sem√¢ntica para descobrir padr√µes existentes de forma inteligente:

```typescript
// 1. An√°lise contextual da funcionalidade
const featureContext = await analyzeFeatureContext({
  featureName: folderName,
  complexity: await estimateComplexity(),
  domain: await identifyDomain(),
  uiComponents: await identifyUIComponents(),
  backendIntegration: await identifyBackendNeeds(),
});

// 2. BUSCA INTELIGENTE - Use termos contextuais para encontrar padr√µes
const searchQueries = await generateContextualSearchQueries(featureContext);

const similarFeatures = await codebase_search({
  query: searchQueries.featurePatterns,
  target_directories: ['src/app/features/'],
});

const similarComponents = await codebase_search({
  query: searchQueries.componentPatterns,
  target_directories: ['src/app/shared/ui-components/'],
});

const architecturalPatterns = await codebase_search({
  query: searchQueries.architecturalPatterns,
  target_directories: ['src/'],
});

// 3. AN√ÅLISE DE DECIS√ïES ANTERIORES
const previousDecisions = await analyzeDecisionHistory({
  featureType: featureContext.type,
  domain: featureContext.domain,
  similarFeatures: similarFeatures,
});
```

- Mantenha o resumo em no m√°ximo 10 bullets e inclua apenas refer√™ncias (caminhos/√¢ncoras), evitando colar conte√∫do integral de documentos.

**üß† PRINC√çPIOS DA DESCOBERTA DE PADR√ïES**:

1. **Busca sem√¢ntica**: Use termos relacionados ao contexto da funcionalidade
2. **An√°lise contextual**: Identifique padr√µes baseados no tipo de funcionalidade
3. **Prioriza√ß√£o inteligente**: Foque nos padr√µes mais relevantes
4. **Aprendizado cont√≠nuo**: Use decis√µes anteriores para melhorar buscas futuras

**üìã PROCESSO DE DESCOBERTA DE PADR√ïES**:

A IA deve:

- [ ] **Gerar termos de busca** baseados no contexto da funcionalidade
- [ ] **Buscar implementa√ß√µes similares** usando busca sem√¢ntica
- [ ] **Analisar padr√µes encontrados** para identificar reutiliza√ß√£o
- [ ] **Mapear decis√µes anteriores** para evitar anti-padr√µes
- [ ] **Identificar oportunidades** de reutiliza√ß√£o de c√≥digo
- [ ] **Documentar padr√µes** para futuras refer√™ncias

##### 2.7: Context Summary Inteligente

**Ap√≥s carregar contexto via navega√ß√£o inteligente, gere automaticamente**:

```markdown
## üß† Context Summary

**Funcionalidade**: [Nome da funcionalidade]
**Complexidade Estimada**: [Baixa/M√©dia/Alta]
**Documentos Analisados**: [Lista de documentos descobertos e lidos]
**Padr√µes Identificados**: [Padr√µes extra√≠dos dos documentos analisados]
**Arquitetura Aplic√°vel**: [Componentes e estruturas relevantes]
**Padr√µes Existentes**: [Implementa√ß√µes similares encontradas no codebase]
**Gaps de Conhecimento**: [√Åreas que precisam de mais contexto]
**Decis√µes Arquiteturais**: [Decis√µes anteriores aplic√°veis]
**Melhores Pr√°ticas Angular**: [Pr√°ticas obtidas via MCP angular-cli]
**Padr√µes de Design System**: [Padr√µes os-* identificados]
**Navega√ß√£o Utilizada**: [Como a IA navegou pelos √≠ndices para descobrir documentos]
**Code Standards Analisados**: [Se√ß√µes espec√≠ficas de code-standards navegadas]
**Estrat√©gia de Testes**: [Documentos de teste analisados e padr√µes identificados]
```

##### 2.8: Aplica√ß√£o Contextual do Conhecimento

**üß† SISTEMA DE APLICA√á√ÉO INTELIGENTE**:

Ap√≥s carregar toda a documenta√ß√£o, execute aplica√ß√£o contextual:

```typescript
// 1. Aplicar padr√µes identificados
const appliedPatterns = await applyIdentifiedPatterns({
  codeStandards: codeStandardsAnalysis,
  frontendArch: frontendArchAnalysis,
  angularBestPractices: angularBestPractices,
  existingPatterns: similarFeatures,
  featureContext: featureAnalysis,
});

// 2. Gerar guidelines espec√≠ficas para a funcionalidade
const featureGuidelines = await generateFeatureGuidelines({
  featureType: featureAnalysis.type,
  complexity: featureAnalysis.complexity,
  patterns: appliedPatterns,
  constraints: featureAnalysis.constraints,
});

// 3. Validar consist√™ncia com padr√µes existentes
const consistencyCheck = await validateConsistency({
  proposedImplementation: featureGuidelines,
  existingCodebase: similarFeatures,
  architecturalRules: frontendArchAnalysis,
});
```

**üìã CHECKLIST DE APLICA√á√ÉO CONTEXTUAL**:

**Padr√µes de C√≥digo**:

- [ ] Aplicar conven√ß√µes de nomenclatura identificadas
- [ ] Seguir estrutura de classes definida
- [ ] Usar padr√µes de import corretos
- [ ] Implementar error handling com Either pattern
- [ ] Aplicar padr√µes Angular modernos (signals, inject, standalone)

**Arquitetura**:

- [ ] Seguir Feature-Based Architecture
- [ ] Respeitar responsabilidades das camadas
- [ ] Implementar comunica√ß√£o entre features conforme padr√£o
- [ ] Aplicar estrat√©gias de state management identificadas
- [ ] Seguir padr√µes de integra√ß√£o com backend

**Design System**:

- [ ] Usar componentes os-\* conforme especificado
- [ ] Aplicar padr√µes de responsividade
- [ ] Implementar acessibilidade conforme guidelines
- [ ] Seguir padr√µes de tema e design tokens

**Estrat√©gia de Testes**:

- [ ] Aplicar padr√µes de teste identificados na documenta√ß√£o
- [ ] Implementar testes unit√°rios conforme guidelines
- [ ] Configurar mocks e factories conforme padr√µes
- [ ] Aplicar estrat√©gias de cobertura identificadas
- [ ] Implementar testes de acessibilidade quando aplic√°vel
- [ ] Seguir padr√µes de teste de componentes Angular

#### Passo 3: Busca e Atualiza√ß√£o do Jira

**_Este passo s√≥ deve ser feito se o trabaho ainda n√£o iniciou. Verifique o status do plano para esta informa√ß√£o. Caso o plano j√° esteja em andamento, ou seja, se alguma fase j√° iniciou, ignore este passo._**

**Fluxo Autom√°tico**:

1. **Buscar Task**: Use `mcp__atlassian__search` com o nome da pasta da sess√£o
2. **Identificar Transi√ß√µes**: Use `mcp__atlassian__getTransitionsForJiraIssue` para encontrar transi√ß√£o "Em Progresso"
3. **Atualizar Status**: Use `mcp__atlassian__transitionJiraIssue` para fazer a transi√ß√£o
4. **Confirmar**: Informe ao usu√°rio: "‚úÖ Task {KEY} atualizada para 'Em Progresso'"

**Tratamento de Erros**:

- Se n√£o encontrar a task: Pergunte ao usu√°rio qual task deve ser atualizada
- Se n√£o encontrar transi√ß√£o: Informe quais transi√ß√µes est√£o dispon√≠veis
- Se der erro de permiss√£o: Informe que o usu√°rio deve atualizar manualmente

**Exemplo de Execu√ß√£o**:

```typescript
// 1. Buscar cloudId
const resources = await mcp__atlassian__getAccessibleAtlassianResources();

// 2. Buscar task baseada na pasta da sess√£o
const searchResults = await mcp__atlassian__search({
  query: '{folder-name}',
});

// 3. Se encontrou, fazer transi√ß√£o
if (searchResults.issues?.length > 0) {
  const issue = searchResults.issues[0];
  const transitions = await mcp__atlassian__getTransitionsForJiraIssue({
    cloudId: resources[0].id,
    issueIdOrKey: issue.key,
  });

  // Encontrar transi√ß√£o para "Em Progresso" / "In Progress"
  const inProgressTransition = transitions.find(
    (t) => t.name.includes('Progress') || t.name.includes('Progresso')
  );

  if (inProgressTransition) {
    await mcp__atlassian__transitionJiraIssue({
      cloudId: resources[0].id,
      issueIdOrKey: issue.key,
      transition: { id: inProgressTransition.id },
    });
  }
}
```

### 4. Implementa√ß√£o da Funcionalidade

**Ap√≥s completar o Context Loading Inteligente, prossiga com a implementa√ß√£o**:

- ADRs (Architecture Decision Records) em `/adr/` se aplic√°vel
- Especifica√ß√µes de dom√≠nio em `/business/` quando relevante
- Outros arquivos que possam ser necess√°rios para o contexto espec√≠fico

**Documentos da Sess√£o**:

Leia todos os arquivos markdown na pasta da sess√£o:

- **context.md**: Entendimento dos requisitos
- **architecture.md**: Design t√©cnico detalhado
- **plan.md**: Plano faseado de implementa√ß√£o
- **layout-specification.md**: Especifica√ß√µes de layout

### 2. An√°lise de Complexidade e Estrat√©gia Adaptativa

### 3. Inicializa√ß√£o do Work Log

Crie o arquivo `sessions/<folder>/work-log.md` se n√£o existir:

Observa√ß√£o: n√£o imprimir o template no output; apenas criar/atualizar o arquivo.

## Template do Work-Log.md

```markdown
# [NOME DA FUNCIONALIDADE] - Log de Desenvolvimento

> **Prop√≥sito**: Registrar progresso essencial, decis√µes t√©cnicas e pr√≥ximos passos.

## üìã Sess√µes de Trabalho

### üóìÔ∏è Sess√£o [DATA] - [DURA√á√ÉO]

**Fase**: [Nome da fase trabalhada]
**Objetivo**: [O que pretendia alcan√ßar]

#### ‚úÖ Trabalho Realizado

- [Tarefa espec√≠fica completada]
- [Funcionalidade implementada]

#### ü§î Decis√µes/Problemas

- **Decis√£o**: [Escolha feita] - **Motivo**: [Raz√£o]
- **Problema**: [Descri√ß√£o] - **Solu√ß√£o**: [Como resolvido]

#### üß™ Valida√ß√µes

- [Teste 1]: [Resultado]
- [Teste 2]: [Resultado]

#### ‚è≠Ô∏è Pr√≥ximos Passos

- [Pr√≥xima tarefa espec√≠fica]
- [Item pendente]

---

## üîÑ Estado Atual

**Branch**: [Nome da branch]
**Fase Atual**: [Nome da fase do plan.md]
**√öltima Modifica√ß√£o**: [Arquivo e descri√ß√£o]
**Pr√≥xima Tarefa**: [Descri√ß√£o espec√≠fica]
```

### 5.5. Valida√ß√µes de Layout

@if (layoutSpecificationExists) {

**Durante implementa√ß√£o de componentes de UI, valide:**

#### Design System Compliance

- [ ] Componentes os-\* utilizados conforme especificado
- [ ] Design tokens (--os-\*) aplicados corretamente
- [ ] Nomenclatura consistente com padr√µes
- [ ] Variantes e tamanhos corretos

#### Responsividade

- [ ] Breakpoints implementados (mobile, tablet, desktop)
- [ ] Touch targets >= 44px em mobile
- [ ] Layout mobile-first
- [ ] Sem scroll horizontal
- [ ] Media queries conforme especifica√ß√£o

#### Acessibilidade

- [ ] ARIA attributes conforme layout-specification
- [ ] Keyboard navigation funcional
- [ ] Focus visible em elementos interativos
- [ ] Screen reader friendly
- [ ] Contraste >= 4.5:1

#### Visual Quality

- [ ] Spacing conforme grid system
- [ ] Estados (loading, error, empty) implementados
- [ ] Micro-interactions conforme especificado
- [ ] Hierarquia visual correta

**Refer√™ncia:** Consulte `layout-specification.md` para detalhes completos

}

### 6. Atualiza√ß√£o do Plano

Ap√≥s completar cada fase:

#### Marcar Conclus√£o

- Atualize o **plan.md** marcando tarefas como \"Completada ‚úÖ\"
- Adicione coment√°rios √∫teis sobre decis√µes tomadas
- Documente quest√µes encontradas e como foram resolvidas
- **Finalize sess√£o** no work-log.md com resumo da fase

#### Exemplo de Atualiza√ß√£o

```markdown
## üìÖ FASE 1: Configura√ß√£o Base [Completada ‚úÖ]

### üìù Coment√°rios da Fase

- **Decis√£o**: Optamos por usar biblioteca X ao inv√©s de Y devido √† melhor performance
- **Problema encontrado**: API Z retornava dados em formato inesperado, adicionamos parser
- **Observa√ß√£o**: Testes da Fase 2 dependem da fixture criada aqui
```

### 7. Fluxo de Aprova√ß√£o Entre Fases

#### Para Cada Fase Completada:

1. **üõë PAUSE**: Apresente resultados ao usu√°rio
2. **üìã Review**: Solicite valida√ß√£o do c√≥digo e approach
3. **üîÑ Iterate**: Fa√ßa ajustes baseados no feedback
4. **‚úÖ Approve**: Aguarde aprova√ß√£o expl√≠cita
5. **üìù Update**: Atualize plan.md com status e coment√°rios
6. **‚ñ∂Ô∏è Next**: Apenas ent√£o inicie pr√≥xima fase

#### Template de Solicita√ß√£o de Aprova√ß√£o

```markdown
## üéØ Fase [X] Completada - Solicita√ß√£o de Aprova√ß√£o

### ‚úÖ Implementado Nesta Fase

[Lista do que foi desenvolvido]

### üß™ Valida√ß√µes Realizadas

[Testes executados e resultados]

### üìã Pr√≥ximos Passos

[O que ser√° abordado na pr√≥xima fase]

**Posso prosseguir para a Fase [X+1]?**
```

### 8. Gest√£o de Branch e Git

#### Branches

- Uma feature branch por funcionalidade: `feature-[slug-da-funcionalidade]`
- Commits frequentes com mensagens descritivas
- N√£o fazer merge at√© aprova√ß√£o final

#### Commits

- Commits por tarefa/subtarefa completada
- Mensagens no formato: `feat: implementa [funcionalidade espec√≠fica]`
- Inclua refer√™ncia √† fase no commit se √∫til

### 9. Ferramentas de Apoio

- **Linting/Formata√ß√£o**: Execute conforme configura√ß√£o do projeto
- **Testes Automatizados**: Execute suite de testes ap√≥s cada implementa√ß√£o
- **Code Analysis**: Use ferramentas MCP para an√°lise de qualidade
- **Documentation**: Consulte Context7 para APIs de bibliotecas

### 10. Finaliza√ß√£o da Implementa√ß√£o

Quando todas as fases estiverem completas:

#### Verifica√ß√£o Final

- [ ] Todos os crit√©rios de aceita√ß√£o atendidos
- [ ] Testes passando completamente
- [ ] C√≥digo segue padr√µes do projeto
- [ ] **üö® CR√çTICO**: Nenhum coment√°rio no c√≥digo final
- [ ] **üö® CR√çTICO**: Nenhum console.log, debugger ou c√≥digo de debug
- [ ] **üö® CR√çTICO**: Nenhum c√≥digo comentado ou "morto"
- [ ] Documenta√ß√£o atualizada se necess√°rio
- [ ] Plan.md completamente atualizado

#### Prepara√ß√£o para PR

- Limpe commits se necess√°rio (squash relacionados)
- Verifique que n√£o h√° c√≥digo tempor√°rio ou debug
- Confirme que branch est√° atualizada
- Execute valida√ß√µes finais (lint, test, build)

#### Handoff

- Atualize status no Jira para \"Ready for Review\"
- Prepare summary das mudan√ßas implementadas
- Informe ao usu√°rio que est√° pronto para `/pre-pr`

## Princ√≠pios de Trabalho

1. **üìö Contexto Inteligente**: Use Context Loading para carregar documentos relevantes (context, architecture, layout-specification)
2. **üß† Mem√≥ria Contextual**: Aplique padr√µes existentes e hist√≥rico
3. **‚ö° Estrat√©gia Adaptativa**: Use an√°lise de complexidade
4. **üé® Layout Compliant**: Siga especifica√ß√µes do layout-specification.md quando existir ‚≠ê NOVO
5. **üîÑ Iterativo**: Trabalhe em pequenas etapas com valida√ß√£o
6. **üéØ Focado**: Siga o plano estabelecido, n√£o se desvie sem discuss√£o
7. **ü§ù Colaborativo**: Sempre busque aprova√ß√£o antes de prosseguir
8. **üîç Qualidade**: Code review cont√≠nuo durante desenvolvimento
9. **üìù Documentado**: Mantenha registros claros de decis√µes e progresso
10. **üéì Aprendizado Cont√≠nuo**: Atualize sistema de mem√≥ria com cada implementa√ß√£o para melhorar futuras decis√µes

## Pr√≥ximos Passos

Ap√≥s completar toda implementa√ß√£o:

1. **Pre-PR** (`/pre-pr`) - Revis√µes automatizadas de qualidade
2. **Pull Request** (`/pr`) - Cria√ß√£o e submiss√£o do PR

---

## ‚ö†Ô∏è LEMBRETE IMPORTANTE

**SEMPRE execute a "Execu√ß√£o Autom√°tica Inicial" (Se√ß√£o 0) ANTES de come√ßar qualquer trabalho:**

1. ‚úÖ Verificar/criar feature branch
2. ‚úÖ **Context Loading Inteligente** (busca autom√°tica + context summary)
3. ‚úÖ **An√°lise de Complexidade** (sele√ß√£o autom√°tica de estrat√©gia)
4. ‚úÖ **Sistema de Mem√≥ria Contextual** (an√°lise de padr√µes existentes)
5. ‚úÖ Buscar e atualizar task no Jira para "Em Progresso"

**N√ÉO pule estes passos** - eles s√£o essenciais para o fluxo de trabalho inteligente e garantem:

- Contexto adequado das boas pr√°ticas e arquitetura
- Estrat√©gia de execu√ß√£o otimizada para a complexidade
- Decis√µes baseadas em padr√µes e hist√≥rico do projeto
- Aprendizado cont√≠nuo para futuras implementa√ß√µes
